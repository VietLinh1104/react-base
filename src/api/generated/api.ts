/* tslint:disable */
/* eslint-disable */
/**
 * EFMS API
 * Enterprise Financial Management System APIs
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, replaceWithSerializableTypeIfNeeded } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface AccountingManagement {
    'department'?: string;
    'costCenter'?: string;
    'debitAccount'?: string;
    'creditAccount'?: string;
}
export interface AccountingManagementResponse {
    'department'?: string;
    'costCenter'?: string;
    'debitAccount'?: string;
    'creditAccount'?: string;
}
export interface AmountCurrencyInfo {
    'originAmount'?: number;
    'currencyCode'?: string;
    'exchangeRate'?: number;
    'withholdingTax'?: number;
    'netAmount'?: number;
    'baseAmount'?: number;
    'vatAmount'?: number;
    'vatRate'?: number;
}
export interface AmountCurrencyInfoResponse {
    'originAmount'?: number;
    'currencyCode'?: string;
    'exchangeRate'?: number;
    'withholdingTax'?: number;
    'netAmount'?: number;
}
export interface AttachmentRequest {
    'fileName'?: string;
    'storageKey'?: string;
    'bucketName'?: string;
    'contentType'?: string;
    'fileSize'?: number;
    'publicUrl'?: string;
    'uploadedAt'?: string;
    'uploadedBy'?: string;
    'entityClass'?: AttachmentRequestEntityClassEnum;
    'entityId'?: string;
}

export const AttachmentRequestEntityClassEnum = {
    Attachments: 'attachments',
    CostCenter: 'cost_center',
    Departments: 'departments',
    EntityAttachments: 'entity_attachments',
    PartnerCounterparty: 'partner_counterparty',
    PartnerType: 'partner_type',
    TransactionType: 'transaction_type',
    Transactions: 'transactions',
    Users: 'users'
} as const;

export type AttachmentRequestEntityClassEnum = typeof AttachmentRequestEntityClassEnum[keyof typeof AttachmentRequestEntityClassEnum];

export interface AttachmentResponse {
    'id'?: string;
    'fileName'?: string;
    'storageKey'?: string;
    'bucketName'?: string;
    'contentType'?: string;
    'fileSize'?: number;
    'publicUrl'?: string;
    'uploadedAt'?: string;
    'uploadedBy'?: UserInfoResponse;
}
export interface AttachmentWrapper {
    'status'?: number;
    'message'?: string;
    'data'?: AttachmentResponse;
}
export interface CostCenter {
    'name'?: string;
    'description'?: string;
    'budgetAmount'?: number;
    'departments'?: Departments;
    'id'?: string;
}
export interface CostCenterWrapper {
    'status'?: number;
    'message'?: string;
    'data'?: PageResponseCostCenter;
}
export interface CreateTransactionRequest {
    'createdBy'?: string;
    'processId'?: number;
    'createdAt'?: string;
    'referenceNo'?: string;
    'documentNo'?: string;
    'transactionType'?: string;
    'description'?: string;
    'documentDate'?: string;
    'accountingPeriod'?: string;
}
export interface DDLResponse {
    'departmentsDDL'?: Array<NameValuePairUUID>;
    'costCenterDDL'?: Array<NameValuePairUUID>;
    'partnerTypeDDL'?: Array<NameValuePairUUID>;
}
export interface DDLWrapper {
    'status'?: number;
    'message'?: string;
    'data'?: DDLResponse;
}
export interface DepartmentResponse {
    'id'?: string;
    'name'?: string;
    'description'?: string;
    'status'?: string;
}
export interface Departments {
    'id'?: string;
    'name'?: string;
    'description'?: string;
    'status'?: string;
}
export interface DepartmentsWrapper {
    'status'?: number;
    'message'?: string;
    'data'?: PageResponseDepartments;
}
export interface ListAttachmentWrapper {
    'status'?: number;
    'message'?: string;
    'data'?: Array<AttachmentResponse>;
}
export interface ListPageAttachmentWrapper {
    'status'?: number;
    'message'?: string;
    'data'?: PageResponseAttachmentResponse;
}
export interface ListTransactionWrapper {
    'status'?: number;
    'message'?: string;
    'data'?: PageResponseMainInfoResponse;
}
export interface LoginRequest {
    'usernameOrEmail'?: string;
    'password'?: string;
}
export interface LoginResponeWrapper {
    'status'?: number;
    'message'?: string;
    'data'?: LoginResponse;
}
export interface LoginResponse {
    'accessToken'?: string;
    'tokenType'?: string;
}
export interface MainInfo {
    'id'?: string;
    'processId'?: number;
    'processStatus'?: MainInfoProcessStatusEnum;
    'referenceNo'?: string;
    'documentNo'?: string;
    'transactionType'?: string;
    'description'?: string;
    'documentDate'?: string;
    'accountingPeriod'?: string;
}

export const MainInfoProcessStatusEnum = {
    EmpCreated: 'EMP_CREATED',
    EmpDraft: 'EMP_DRAFT',
    EmpSubmited: 'EMP_SUBMITED',
    AccRecepted: 'ACC_RECEPTED',
    AccReturn: 'ACC_RETURN',
    AccRejected: 'ACC_REJECTED',
    AccApproved: 'ACC_APPROVED',
    RdRecepted: 'RD_RECEPTED',
    RdReturn: 'RD_RETURN',
    RdAccepted: 'RD_ACCEPTED',
    Canceled: 'CANCELED'
} as const;

export type MainInfoProcessStatusEnum = typeof MainInfoProcessStatusEnum[keyof typeof MainInfoProcessStatusEnum];

export interface MainInfoResponse {
    'id'?: string;
    'processId'?: number;
    'processStatus'?: MainInfoResponseProcessStatusEnum;
    'createdBy'?: string;
    'referenceNo'?: string;
    'documentNo'?: string;
    'createdAt'?: string;
    'updatedAt'?: string;
    'transactionType'?: string;
    'description'?: string;
    'documentDate'?: string;
    'accountingPeriod'?: string;
}

export const MainInfoResponseProcessStatusEnum = {
    EmpCreated: 'EMP_CREATED',
    EmpDraft: 'EMP_DRAFT',
    EmpSubmited: 'EMP_SUBMITED',
    AccRecepted: 'ACC_RECEPTED',
    AccReturn: 'ACC_RETURN',
    AccRejected: 'ACC_REJECTED',
    AccApproved: 'ACC_APPROVED',
    RdRecepted: 'RD_RECEPTED',
    RdReturn: 'RD_RETURN',
    RdAccepted: 'RD_ACCEPTED',
    Canceled: 'CANCELED'
} as const;

export type MainInfoResponseProcessStatusEnum = typeof MainInfoResponseProcessStatusEnum[keyof typeof MainInfoResponseProcessStatusEnum];

export interface MainInfoWrapper {
    'status'?: number;
    'message'?: string;
    'data'?: MainInfoResponse;
}
export interface NameValuePairUUID {
    'name'?: string;
    'value'?: string;
}
export interface PageResponseAttachmentResponse {
    'page'?: number;
    'pageSize'?: number;
    'totalElement'?: number;
    'totalPage'?: number;
    'data'?: Array<AttachmentResponse>;
}
export interface PageResponseCostCenter {
    'page'?: number;
    'pageSize'?: number;
    'totalElement'?: number;
    'totalPage'?: number;
    'data'?: Array<CostCenter>;
}
export interface PageResponseDepartments {
    'page'?: number;
    'pageSize'?: number;
    'totalElement'?: number;
    'totalPage'?: number;
    'data'?: Array<Departments>;
}
export interface PageResponseMainInfoResponse {
    'page'?: number;
    'pageSize'?: number;
    'totalElement'?: number;
    'totalPage'?: number;
    'data'?: Array<MainInfoResponse>;
}
export interface PageResponsePartnerCounterparty {
    'page'?: number;
    'pageSize'?: number;
    'totalElement'?: number;
    'totalPage'?: number;
    'data'?: Array<PartnerCounterparty>;
}
export interface PageResponseRegisterResponse {
    'page'?: number;
    'pageSize'?: number;
    'totalElement'?: number;
    'totalPage'?: number;
    'data'?: Array<RegisterResponse>;
}
export interface PageResponseUserTask {
    'page'?: number;
    'pageSize'?: number;
    'totalElement'?: number;
    'totalPage'?: number;
    'data'?: Array<UserTask>;
}
export interface PartnerCounterparty {
    'id'?: string;
    'name'?: string;
    'partnerType'?: PartnerType;
    'taxCode'?: string;
    'bankName'?: string;
    'bankAccount'?: string;
    'contactPerson'?: string;
    'phoneNumber'?: string;
}
export interface PartnerCounterpartyWrapper {
    'status'?: number;
    'message'?: string;
    'data'?: PageResponsePartnerCounterparty;
}
export interface PartnerInfo {
    'partnerCode'?: string;
    'partnerType'?: string;
    'partnerName'?: string;
    'taxCode'?: string;
    'bankName'?: string;
    'bankAcc'?: string;
    'contactPer'?: string;
    'phoneNo'?: string;
}
export interface PartnerInfoResponse {
    'partnerCode'?: string;
    'partnerName'?: string;
    'partnerType'?: string;
    'taxCode'?: string;
    'bankName'?: string;
    'bankAcc'?: string;
    'contactPer'?: string;
    'phoneNo'?: string;
}
export interface PartnerType {
    'id'?: string;
    'name'?: string;
    'description'?: string;
}
export interface PaymentInfo {
    'paymentMethodId'?: string;
    'paymentStatus'?: string;
    'paymentDate'?: string;
    'paymentRef'?: string;
    'bankLedger'?: string;
    'cashLedger'?: string;
    'paidAmount'?: number;
    'remainingAmount'?: number;
}
export interface PaymentInfoResponse {
    'paymentMethodId'?: string;
    'paymentStatus'?: string;
    'paymentDate'?: string;
    'paymentRef'?: string;
    'bankLedger'?: string;
    'cashLedger'?: string;
    'paidAmount'?: number;
    'remainingAmount'?: number;
}
export interface ProcessInstanceEvent {
    'version'?: number;
    'tags'?: Set<string>;
    'tenantId'?: string;
    'processInstanceKey'?: number;
    'processDefinitionKey'?: number;
    'bpmnProcessId'?: string;
}
export interface ProcessInstanceEventWrapper {
    'status'?: number;
    'message'?: string;
    'data'?: ProcessInstanceEvent;
}
export interface RegisterRequest {
    'username'?: string;
    'fullName'?: string;
    'email'?: string;
    'password'?: string;
    'role'?: string;
    'departmentId'?: string;
}
export interface RegisterResponeWrapper {
    'status'?: number;
    'message'?: string;
    'data'?: PageResponseRegisterResponse;
}
export interface RegisterResponse {
    'accessToken'?: string;
    'tokenType'?: string;
}
export interface ResponseObject {
    'status'?: number;
    'message'?: string;
    'data'?: object;
}
export interface ResponseVoid {
    'status'?: number;
    'message'?: string;
    'data'?: object;
}
export interface TransactionRequest {
    'mainInfo'?: MainInfo;
    'accountingManagement'?: AccountingManagement;
    'partnerInfo'?: PartnerInfo;
    'amountCurrencyInfo'?: AmountCurrencyInfo;
    'paymentInfo'?: PaymentInfo;
}
export interface TransactionResponse {
    'mainInfo'?: MainInfoResponse;
    'accountingManagement'?: AccountingManagementResponse;
    'partnerInfo'?: PartnerInfoResponse;
    'amountCurrencyInfo'?: AmountCurrencyInfoResponse;
    'paymentInfo'?: PaymentInfoResponse;
}
export interface TransactionsWrapper {
    'status'?: number;
    'message'?: string;
    'data'?: TransactionResponse;
}
export interface UserInfoResponse {
    'id'?: string;
    'username'?: string;
    'fullName'?: string;
    'email'?: string;
    'department'?: DepartmentResponse;
    'status'?: string;
    'role'?: string;
    'createdAt'?: string;
    'updatedAt'?: string;
}
export interface UserTask {
    'name'?: string;
    'priority'?: number;
    'state'?: UserTaskStateEnum;
    'processName'?: string;
    'candidateGroups'?: Array<string>;
    'completionDate'?: string;
    'followUpDate'?: string;
    'candidateUsers'?: Array<string>;
    'tenantId'?: string;
    'assignee'?: string;
    'userTaskKey'?: number;
    'elementId'?: string;
    'processInstanceKey'?: number;
    'processDefinitionKey'?: number;
    'bpmnProcessId'?: string;
    'customHeaders'?: { [key: string]: string; };
    'formKey'?: number;
    'dueDate'?: string;
    'creationDate'?: string;
    'processDefinitionVersion'?: number;
    'elementInstanceKey'?: number;
    'externalFormReference'?: string;
}

export const UserTaskStateEnum = {
    Creating: 'CREATING',
    Created: 'CREATED',
    Assigning: 'ASSIGNING',
    Updating: 'UPDATING',
    Completing: 'COMPLETING',
    Completed: 'COMPLETED',
    Canceling: 'CANCELING',
    Canceled: 'CANCELED',
    Failed: 'FAILED',
    UnknownEnumValue: 'UNKNOWN_ENUM_VALUE'
} as const;

export type UserTaskStateEnum = typeof UserTaskStateEnum[keyof typeof UserTaskStateEnum];

export interface UserTaskResponse {
    'taskKey'?: number;
    'taskName'?: string;
    'taskDefinitionId'?: string;
    'processDefinitionKey'?: number;
    'processInstanceKey'?: number;
    'state'?: UserTaskResponseStateEnum;
    'assignee'?: string;
    'transaction'?: TransactionResponse;
}

export const UserTaskResponseStateEnum = {
    Creating: 'CREATING',
    Created: 'CREATED',
    Assigning: 'ASSIGNING',
    Updating: 'UPDATING',
    Completing: 'COMPLETING',
    Completed: 'COMPLETED',
    Canceling: 'CANCELING',
    Canceled: 'CANCELED',
    Failed: 'FAILED',
    UnknownEnumValue: 'UNKNOWN_ENUM_VALUE'
} as const;

export type UserTaskResponseStateEnum = typeof UserTaskResponseStateEnum[keyof typeof UserTaskResponseStateEnum];

export interface UserTaskTransactionWrapper {
    'status'?: number;
    'message'?: string;
    'data'?: UserTaskResponse;
}
export interface UserTaskWrapper {
    'status'?: number;
    'message'?: string;
    'data'?: PageResponseUserTask;
}

/**
 * AttachmentManagementApi - axios parameter creator
 */
export const AttachmentManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Lưu thông tin file và có thể liên kết ngay với một entity
         * @summary Tạo mới attachment
         * @param {AttachmentRequest} attachmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAttachment: async (attachmentRequest: AttachmentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attachmentRequest' is not null or undefined
            assertParamExists('createAttachment', 'attachmentRequest', attachmentRequest)
            const localVarPath = `/api/attachments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = '*/*,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Xóa vĩnh viễn attachment
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttachment: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAttachment', 'id', id)
            const localVarPath = `/api/attachments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = '*/*,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Xóa thông minh (Smart Delete)
         * @param {string} id 
         * @param {string} entityId 
         * @param {DeleteSmartEntityTypeEnum} entityType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSmart: async (id: string, entityId: string, entityType: DeleteSmartEntityTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSmart', 'id', id)
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('deleteSmart', 'entityId', entityId)
            // verify required parameter 'entityType' is not null or undefined
            assertParamExists('deleteSmart', 'entityType', entityType)
            const localVarPath = `/api/attachments/{id}/smart`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (entityId !== undefined) {
                localVarQueryParameter['entityId'] = entityId;
            }

            if (entityType !== undefined) {
                localVarQueryParameter['entityType'] = entityType;
            }

            localVarHeaderParameter['Accept'] = '*/*,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lấy toàn bộ file đính kèm trên hệ thống
         * @summary Danh sách attachment phân trang
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAttachments: async (page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/attachments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarHeaderParameter['Accept'] = '*/*,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lấy attachment theo thực thể
         * @param {string} entityId 
         * @param {GetAttachmentsByEntityEntityTypeEnum} entityType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentsByEntity: async (entityId: string, entityType: GetAttachmentsByEntityEntityTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('getAttachmentsByEntity', 'entityId', entityId)
            // verify required parameter 'entityType' is not null or undefined
            assertParamExists('getAttachmentsByEntity', 'entityType', entityType)
            const localVarPath = `/api/attachments/entity/{entityId}`
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (entityType !== undefined) {
                localVarQueryParameter['entityType'] = entityType;
            }

            localVarHeaderParameter['Accept'] = '*/*,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gán attachment vào thực thể
         * @param {string} id 
         * @param {LinkAttachmentToEntityEntityTypeEnum} entityType 
         * @param {string} entityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkAttachmentToEntity: async (id: string, entityType: LinkAttachmentToEntityEntityTypeEnum, entityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('linkAttachmentToEntity', 'id', id)
            // verify required parameter 'entityType' is not null or undefined
            assertParamExists('linkAttachmentToEntity', 'entityType', entityType)
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('linkAttachmentToEntity', 'entityId', entityId)
            const localVarPath = `/api/attachments/{id}/link`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (entityType !== undefined) {
                localVarQueryParameter['entityType'] = entityType;
            }

            if (entityId !== undefined) {
                localVarQueryParameter['entityId'] = entityId;
            }

            localVarHeaderParameter['Accept'] = '*/*,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Xóa liên kết
         * @param {string} id 
         * @param {string} entityId 
         * @param {UnlinkAttachmentEntityTypeEnum} entityType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkAttachment: async (id: string, entityId: string, entityType: UnlinkAttachmentEntityTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unlinkAttachment', 'id', id)
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('unlinkAttachment', 'entityId', entityId)
            // verify required parameter 'entityType' is not null or undefined
            assertParamExists('unlinkAttachment', 'entityType', entityType)
            const localVarPath = `/api/attachments/{id}/link`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (entityId !== undefined) {
                localVarQueryParameter['entityId'] = entityId;
            }

            if (entityType !== undefined) {
                localVarQueryParameter['entityType'] = entityType;
            }

            localVarHeaderParameter['Accept'] = '*/*,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AttachmentManagementApi - functional programming interface
 */
export const AttachmentManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AttachmentManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * Lưu thông tin file và có thể liên kết ngay với một entity
         * @summary Tạo mới attachment
         * @param {AttachmentRequest} attachmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAttachment(attachmentRequest: AttachmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachmentWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAttachment(attachmentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttachmentManagementApi.createAttachment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Xóa vĩnh viễn attachment
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAttachment(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAttachment(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttachmentManagementApi.deleteAttachment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Xóa thông minh (Smart Delete)
         * @param {string} id 
         * @param {string} entityId 
         * @param {DeleteSmartEntityTypeEnum} entityType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSmart(id: string, entityId: string, entityType: DeleteSmartEntityTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSmart(id, entityId, entityType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttachmentManagementApi.deleteSmart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lấy toàn bộ file đính kèm trên hệ thống
         * @summary Danh sách attachment phân trang
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllAttachments(page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPageAttachmentWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAttachments(page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttachmentManagementApi.getAllAttachments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Lấy attachment theo thực thể
         * @param {string} entityId 
         * @param {GetAttachmentsByEntityEntityTypeEnum} entityType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAttachmentsByEntity(entityId: string, entityType: GetAttachmentsByEntityEntityTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAttachmentWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAttachmentsByEntity(entityId, entityType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttachmentManagementApi.getAttachmentsByEntity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gán attachment vào thực thể
         * @param {string} id 
         * @param {LinkAttachmentToEntityEntityTypeEnum} entityType 
         * @param {string} entityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkAttachmentToEntity(id: string, entityType: LinkAttachmentToEntityEntityTypeEnum, entityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachmentWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.linkAttachmentToEntity(id, entityType, entityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttachmentManagementApi.linkAttachmentToEntity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Xóa liên kết
         * @param {string} id 
         * @param {string} entityId 
         * @param {UnlinkAttachmentEntityTypeEnum} entityType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlinkAttachment(id: string, entityId: string, entityType: UnlinkAttachmentEntityTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlinkAttachment(id, entityId, entityType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttachmentManagementApi.unlinkAttachment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AttachmentManagementApi - factory interface
 */
export const AttachmentManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AttachmentManagementApiFp(configuration)
    return {
        /**
         * Lưu thông tin file và có thể liên kết ngay với một entity
         * @summary Tạo mới attachment
         * @param {AttachmentRequest} attachmentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAttachment(attachmentRequest: AttachmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<AttachmentWrapper> {
            return localVarFp.createAttachment(attachmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Xóa vĩnh viễn attachment
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttachment(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteAttachment(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Xóa thông minh (Smart Delete)
         * @param {string} id 
         * @param {string} entityId 
         * @param {DeleteSmartEntityTypeEnum} entityType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSmart(id: string, entityId: string, entityType: DeleteSmartEntityTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSmart(id, entityId, entityType, options).then((request) => request(axios, basePath));
        },
        /**
         * Lấy toàn bộ file đính kèm trên hệ thống
         * @summary Danh sách attachment phân trang
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAttachments(page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListPageAttachmentWrapper> {
            return localVarFp.getAllAttachments(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lấy attachment theo thực thể
         * @param {string} entityId 
         * @param {GetAttachmentsByEntityEntityTypeEnum} entityType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentsByEntity(entityId: string, entityType: GetAttachmentsByEntityEntityTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<ListAttachmentWrapper> {
            return localVarFp.getAttachmentsByEntity(entityId, entityType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gán attachment vào thực thể
         * @param {string} id 
         * @param {LinkAttachmentToEntityEntityTypeEnum} entityType 
         * @param {string} entityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkAttachmentToEntity(id: string, entityType: LinkAttachmentToEntityEntityTypeEnum, entityId: string, options?: RawAxiosRequestConfig): AxiosPromise<AttachmentWrapper> {
            return localVarFp.linkAttachmentToEntity(id, entityType, entityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Xóa liên kết
         * @param {string} id 
         * @param {string} entityId 
         * @param {UnlinkAttachmentEntityTypeEnum} entityType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkAttachment(id: string, entityId: string, entityType: UnlinkAttachmentEntityTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.unlinkAttachment(id, entityId, entityType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AttachmentManagementApi - object-oriented interface
 */
export class AttachmentManagementApi extends BaseAPI {
    /**
     * Lưu thông tin file và có thể liên kết ngay với một entity
     * @summary Tạo mới attachment
     * @param {AttachmentRequest} attachmentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createAttachment(attachmentRequest: AttachmentRequest, options?: RawAxiosRequestConfig) {
        return AttachmentManagementApiFp(this.configuration).createAttachment(attachmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Xóa vĩnh viễn attachment
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteAttachment(id: string, options?: RawAxiosRequestConfig) {
        return AttachmentManagementApiFp(this.configuration).deleteAttachment(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Xóa thông minh (Smart Delete)
     * @param {string} id 
     * @param {string} entityId 
     * @param {DeleteSmartEntityTypeEnum} entityType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteSmart(id: string, entityId: string, entityType: DeleteSmartEntityTypeEnum, options?: RawAxiosRequestConfig) {
        return AttachmentManagementApiFp(this.configuration).deleteSmart(id, entityId, entityType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lấy toàn bộ file đính kèm trên hệ thống
     * @summary Danh sách attachment phân trang
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAllAttachments(page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return AttachmentManagementApiFp(this.configuration).getAllAttachments(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lấy attachment theo thực thể
     * @param {string} entityId 
     * @param {GetAttachmentsByEntityEntityTypeEnum} entityType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAttachmentsByEntity(entityId: string, entityType: GetAttachmentsByEntityEntityTypeEnum, options?: RawAxiosRequestConfig) {
        return AttachmentManagementApiFp(this.configuration).getAttachmentsByEntity(entityId, entityType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gán attachment vào thực thể
     * @param {string} id 
     * @param {LinkAttachmentToEntityEntityTypeEnum} entityType 
     * @param {string} entityId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public linkAttachmentToEntity(id: string, entityType: LinkAttachmentToEntityEntityTypeEnum, entityId: string, options?: RawAxiosRequestConfig) {
        return AttachmentManagementApiFp(this.configuration).linkAttachmentToEntity(id, entityType, entityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Xóa liên kết
     * @param {string} id 
     * @param {string} entityId 
     * @param {UnlinkAttachmentEntityTypeEnum} entityType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public unlinkAttachment(id: string, entityId: string, entityType: UnlinkAttachmentEntityTypeEnum, options?: RawAxiosRequestConfig) {
        return AttachmentManagementApiFp(this.configuration).unlinkAttachment(id, entityId, entityType, options).then((request) => request(this.axios, this.basePath));
    }
}

export const DeleteSmartEntityTypeEnum = {
    Attachments: 'attachments',
    CostCenter: 'cost_center',
    Departments: 'departments',
    EntityAttachments: 'entity_attachments',
    PartnerCounterparty: 'partner_counterparty',
    PartnerType: 'partner_type',
    TransactionType: 'transaction_type',
    Transactions: 'transactions',
    Users: 'users'
} as const;
export type DeleteSmartEntityTypeEnum = typeof DeleteSmartEntityTypeEnum[keyof typeof DeleteSmartEntityTypeEnum];
export const GetAttachmentsByEntityEntityTypeEnum = {
    Attachments: 'attachments',
    CostCenter: 'cost_center',
    Departments: 'departments',
    EntityAttachments: 'entity_attachments',
    PartnerCounterparty: 'partner_counterparty',
    PartnerType: 'partner_type',
    TransactionType: 'transaction_type',
    Transactions: 'transactions',
    Users: 'users'
} as const;
export type GetAttachmentsByEntityEntityTypeEnum = typeof GetAttachmentsByEntityEntityTypeEnum[keyof typeof GetAttachmentsByEntityEntityTypeEnum];
export const LinkAttachmentToEntityEntityTypeEnum = {
    Attachments: 'attachments',
    CostCenter: 'cost_center',
    Departments: 'departments',
    EntityAttachments: 'entity_attachments',
    PartnerCounterparty: 'partner_counterparty',
    PartnerType: 'partner_type',
    TransactionType: 'transaction_type',
    Transactions: 'transactions',
    Users: 'users'
} as const;
export type LinkAttachmentToEntityEntityTypeEnum = typeof LinkAttachmentToEntityEntityTypeEnum[keyof typeof LinkAttachmentToEntityEntityTypeEnum];
export const UnlinkAttachmentEntityTypeEnum = {
    Attachments: 'attachments',
    CostCenter: 'cost_center',
    Departments: 'departments',
    EntityAttachments: 'entity_attachments',
    PartnerCounterparty: 'partner_counterparty',
    PartnerType: 'partner_type',
    TransactionType: 'transaction_type',
    Transactions: 'transactions',
    Users: 'users'
} as const;
export type UnlinkAttachmentEntityTypeEnum = typeof UnlinkAttachmentEntityTypeEnum[keyof typeof UnlinkAttachmentEntityTypeEnum];


/**
 * AuthControllerApi - axios parameter creator
 */
export const AuthControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Đăng nhập
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('login', 'loginRequest', loginRequest)
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = '*/*,application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Đăng xuất
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = '*/*';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Đăng ký
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (registerRequest: RegisterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerRequest' is not null or undefined
            assertParamExists('register', 'registerRequest', registerRequest)
            const localVarPath = `/api/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthControllerApi - functional programming interface
 */
export const AuthControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Đăng nhập
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponeWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthControllerApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Đăng xuất
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthControllerApi.logout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Đăng ký
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterResponeWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(registerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthControllerApi.register']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthControllerApi - factory interface
 */
export const AuthControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary Đăng nhập
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponeWrapper> {
            return localVarFp.login(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Đăng xuất
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Đăng ký
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig): AxiosPromise<RegisterResponeWrapper> {
            return localVarFp.register(registerRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthControllerApi - object-oriented interface
 */
export class AuthControllerApi extends BaseAPI {
    /**
     * 
     * @summary Đăng nhập
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
        return AuthControllerApiFp(this.configuration).login(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Đăng xuất
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public logout(options?: RawAxiosRequestConfig) {
        return AuthControllerApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Đăng ký
     * @param {RegisterRequest} registerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public register(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig) {
        return AuthControllerApiFp(this.configuration).register(registerRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CostCenterControllerApi - axios parameter creator
 */
export const CostCenterControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lấy danh sách phân trang dự án
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [departmentId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCostCenterPage: async (page?: number, pageSize?: number, departmentId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/cost-center`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (departmentId !== undefined) {
                localVarQueryParameter['departmentId'] = departmentId;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CostCenterControllerApi - functional programming interface
 */
export const CostCenterControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CostCenterControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Lấy danh sách phân trang dự án
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [departmentId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCostCenterPage(page?: number, pageSize?: number, departmentId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CostCenterWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCostCenterPage(page, pageSize, departmentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CostCenterControllerApi.getAllCostCenterPage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CostCenterControllerApi - factory interface
 */
export const CostCenterControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CostCenterControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary Lấy danh sách phân trang dự án
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [departmentId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCostCenterPage(page?: number, pageSize?: number, departmentId?: string, options?: RawAxiosRequestConfig): AxiosPromise<CostCenterWrapper> {
            return localVarFp.getAllCostCenterPage(page, pageSize, departmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CostCenterControllerApi - object-oriented interface
 */
export class CostCenterControllerApi extends BaseAPI {
    /**
     * 
     * @summary Lấy danh sách phân trang dự án
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [departmentId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAllCostCenterPage(page?: number, pageSize?: number, departmentId?: string, options?: RawAxiosRequestConfig) {
        return CostCenterControllerApiFp(this.configuration).getAllCostCenterPage(page, pageSize, departmentId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DdlControllerApi - axios parameter creator
 */
export const DdlControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lấy danh sách DDL giao dịch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDDLTransactionDetail: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/ddl`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DdlControllerApi - functional programming interface
 */
export const DdlControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DdlControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Lấy danh sách DDL giao dịch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDDLTransactionDetail(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DDLWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDDLTransactionDetail(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DdlControllerApi.getDDLTransactionDetail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DdlControllerApi - factory interface
 */
export const DdlControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DdlControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary Lấy danh sách DDL giao dịch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDDLTransactionDetail(options?: RawAxiosRequestConfig): AxiosPromise<DDLWrapper> {
            return localVarFp.getDDLTransactionDetail(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DdlControllerApi - object-oriented interface
 */
export class DdlControllerApi extends BaseAPI {
    /**
     * 
     * @summary Lấy danh sách DDL giao dịch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDDLTransactionDetail(options?: RawAxiosRequestConfig) {
        return DdlControllerApiFp(this.configuration).getDDLTransactionDetail(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DepartmentsControllerApi - axios parameter creator
 */
export const DepartmentsControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lấy danh sách phân trang phòng ban
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDepartmentPage: async (page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/departments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DepartmentsControllerApi - functional programming interface
 */
export const DepartmentsControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DepartmentsControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Lấy danh sách phân trang phòng ban
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllDepartmentPage(page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepartmentsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllDepartmentPage(page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepartmentsControllerApi.getAllDepartmentPage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DepartmentsControllerApi - factory interface
 */
export const DepartmentsControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DepartmentsControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary Lấy danh sách phân trang phòng ban
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDepartmentPage(page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<DepartmentsWrapper> {
            return localVarFp.getAllDepartmentPage(page, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DepartmentsControllerApi - object-oriented interface
 */
export class DepartmentsControllerApi extends BaseAPI {
    /**
     * 
     * @summary Lấy danh sách phân trang phòng ban
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAllDepartmentPage(page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return DepartmentsControllerApiFp(this.configuration).getAllDepartmentPage(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PartnerCounterpartyControllerApi - axios parameter creator
 */
export const PartnerCounterpartyControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lấy danh sách phân trang đối tác
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPartnerCounterpartyPage: async (page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/partner-counterparty`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PartnerCounterpartyControllerApi - functional programming interface
 */
export const PartnerCounterpartyControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PartnerCounterpartyControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Lấy danh sách phân trang đối tác
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPartnerCounterpartyPage(page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerCounterpartyWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPartnerCounterpartyPage(page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PartnerCounterpartyControllerApi.getAllPartnerCounterpartyPage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PartnerCounterpartyControllerApi - factory interface
 */
export const PartnerCounterpartyControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PartnerCounterpartyControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary Lấy danh sách phân trang đối tác
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPartnerCounterpartyPage(page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<PartnerCounterpartyWrapper> {
            return localVarFp.getAllPartnerCounterpartyPage(page, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PartnerCounterpartyControllerApi - object-oriented interface
 */
export class PartnerCounterpartyControllerApi extends BaseAPI {
    /**
     * 
     * @summary Lấy danh sách phân trang đối tác
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAllPartnerCounterpartyPage(page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return PartnerCounterpartyControllerApiFp(this.configuration).getAllPartnerCounterpartyPage(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProcessControllerApi - axios parameter creator
 */
export const ProcessControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Khởi tạo giao dịch
         * @param {CreateTransactionRequest} createTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProcess: async (createTransactionRequest: CreateTransactionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTransactionRequest' is not null or undefined
            assertParamExists('startProcess', 'createTransactionRequest', createTransactionRequest)
            const localVarPath = `/process/create-transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTransactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProcessControllerApi - functional programming interface
 */
export const ProcessControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProcessControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Khởi tạo giao dịch
         * @param {CreateTransactionRequest} createTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startProcess(createTransactionRequest: CreateTransactionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessInstanceEventWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startProcess(createTransactionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProcessControllerApi.startProcess']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProcessControllerApi - factory interface
 */
export const ProcessControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProcessControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary Khởi tạo giao dịch
         * @param {CreateTransactionRequest} createTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProcess(createTransactionRequest: CreateTransactionRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProcessInstanceEventWrapper> {
            return localVarFp.startProcess(createTransactionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProcessControllerApi - object-oriented interface
 */
export class ProcessControllerApi extends BaseAPI {
    /**
     * 
     * @summary Khởi tạo giao dịch
     * @param {CreateTransactionRequest} createTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public startProcess(createTransactionRequest: CreateTransactionRequest, options?: RawAxiosRequestConfig) {
        return ProcessControllerApiFp(this.configuration).startProcess(createTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TransactionControllerApi - axios parameter creator
 */
export const TransactionControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Khởi tạo giao dịch
         * @param {CreateTransactionRequest} createTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransaction: async (createTransactionRequest: CreateTransactionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTransactionRequest' is not null or undefined
            assertParamExists('createTransaction', 'createTransactionRequest', createTransactionRequest)
            const localVarPath = `/api/transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTransactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lấy danh sách giao dịch phân trang
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactions: async (page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lấy chi tiết giao dịch
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetailTransactionById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDetailTransactionById', 'id', id)
            const localVarPath = `/api/transaction/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cập nhật giao dịch
         * @param {string} id 
         * @param {TransactionRequest} transactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransaction1: async (id: string, transactionRequest: TransactionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTransaction1', 'id', id)
            // verify required parameter 'transactionRequest' is not null or undefined
            assertParamExists('updateTransaction1', 'transactionRequest', transactionRequest)
            const localVarPath = `/api/transaction/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionControllerApi - functional programming interface
 */
export const TransactionControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Khởi tạo giao dịch
         * @param {CreateTransactionRequest} createTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransaction(createTransactionRequest: CreateTransactionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainInfoWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransaction(createTransactionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionControllerApi.createTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Lấy danh sách giao dịch phân trang
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTransactions(page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListTransactionWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTransactions(page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionControllerApi.getAllTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Lấy chi tiết giao dịch
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDetailTransactionById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionsWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDetailTransactionById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionControllerApi.getDetailTransactionById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cập nhật giao dịch
         * @param {string} id 
         * @param {TransactionRequest} transactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTransaction1(id: string, transactionRequest: TransactionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainInfoWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTransaction1(id, transactionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionControllerApi.updateTransaction1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TransactionControllerApi - factory interface
 */
export const TransactionControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary Khởi tạo giao dịch
         * @param {CreateTransactionRequest} createTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransaction(createTransactionRequest: CreateTransactionRequest, options?: RawAxiosRequestConfig): AxiosPromise<MainInfoWrapper> {
            return localVarFp.createTransaction(createTransactionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lấy danh sách giao dịch phân trang
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTransactions(page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListTransactionWrapper> {
            return localVarFp.getAllTransactions(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lấy chi tiết giao dịch
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetailTransactionById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<TransactionsWrapper> {
            return localVarFp.getDetailTransactionById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cập nhật giao dịch
         * @param {string} id 
         * @param {TransactionRequest} transactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransaction1(id: string, transactionRequest: TransactionRequest, options?: RawAxiosRequestConfig): AxiosPromise<MainInfoWrapper> {
            return localVarFp.updateTransaction1(id, transactionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionControllerApi - object-oriented interface
 */
export class TransactionControllerApi extends BaseAPI {
    /**
     * 
     * @summary Khởi tạo giao dịch
     * @param {CreateTransactionRequest} createTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createTransaction(createTransactionRequest: CreateTransactionRequest, options?: RawAxiosRequestConfig) {
        return TransactionControllerApiFp(this.configuration).createTransaction(createTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lấy danh sách giao dịch phân trang
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAllTransactions(page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return TransactionControllerApiFp(this.configuration).getAllTransactions(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lấy chi tiết giao dịch
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDetailTransactionById(id: string, options?: RawAxiosRequestConfig) {
        return TransactionControllerApiFp(this.configuration).getDetailTransactionById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cập nhật giao dịch
     * @param {string} id 
     * @param {TransactionRequest} transactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateTransaction1(id: string, transactionRequest: TransactionRequest, options?: RawAxiosRequestConfig) {
        return TransactionControllerApiFp(this.configuration).updateTransaction1(id, transactionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserTaskControllerApi - axios parameter creator
 */
export const UserTaskControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lấy danh sách giao dịch phân trang
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {GetAllTasksStateEnum} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTasks: async (page?: number, pageSize?: number, state?: GetAllTasksStateEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user-tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lấy chi tiết giao dịch taskKey
         * @param {number} taskKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetailTransactionByTaskKey: async (taskKey: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskKey' is not null or undefined
            assertParamExists('getDetailTransactionByTaskKey', 'taskKey', taskKey)
            const localVarPath = `/api/v1/user-tasks/{taskKey}`
                .replace(`{${"taskKey"}}`, encodeURIComponent(String(taskKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Hành động giao dịch
         * @param {number} taskKey 
         * @param {UpdateTransactionProcessStatusEnum} processStatus 
         * @param {TransactionRequest} transactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransaction: async (taskKey: number, processStatus: UpdateTransactionProcessStatusEnum, transactionRequest: TransactionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskKey' is not null or undefined
            assertParamExists('updateTransaction', 'taskKey', taskKey)
            // verify required parameter 'processStatus' is not null or undefined
            assertParamExists('updateTransaction', 'processStatus', processStatus)
            // verify required parameter 'transactionRequest' is not null or undefined
            assertParamExists('updateTransaction', 'transactionRequest', transactionRequest)
            const localVarPath = `/api/v1/user-tasks/action/{taskKey}/{processStatus}`
                .replace(`{${"taskKey"}}`, encodeURIComponent(String(taskKey)))
                .replace(`{${"processStatus"}}`, encodeURIComponent(String(processStatus)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserTaskControllerApi - functional programming interface
 */
export const UserTaskControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserTaskControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Lấy danh sách giao dịch phân trang
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {GetAllTasksStateEnum} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTasks(page?: number, pageSize?: number, state?: GetAllTasksStateEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTaskWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTasks(page, pageSize, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserTaskControllerApi.getAllTasks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Lấy chi tiết giao dịch taskKey
         * @param {number} taskKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDetailTransactionByTaskKey(taskKey: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTaskTransactionWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDetailTransactionByTaskKey(taskKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserTaskControllerApi.getDetailTransactionByTaskKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Hành động giao dịch
         * @param {number} taskKey 
         * @param {UpdateTransactionProcessStatusEnum} processStatus 
         * @param {TransactionRequest} transactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTransaction(taskKey: number, processStatus: UpdateTransactionProcessStatusEnum, transactionRequest: TransactionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MainInfoWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTransaction(taskKey, processStatus, transactionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserTaskControllerApi.updateTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserTaskControllerApi - factory interface
 */
export const UserTaskControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserTaskControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary Lấy danh sách giao dịch phân trang
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {GetAllTasksStateEnum} [state] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTasks(page?: number, pageSize?: number, state?: GetAllTasksStateEnum, options?: RawAxiosRequestConfig): AxiosPromise<UserTaskWrapper> {
            return localVarFp.getAllTasks(page, pageSize, state, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lấy chi tiết giao dịch taskKey
         * @param {number} taskKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetailTransactionByTaskKey(taskKey: number, options?: RawAxiosRequestConfig): AxiosPromise<UserTaskTransactionWrapper> {
            return localVarFp.getDetailTransactionByTaskKey(taskKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Hành động giao dịch
         * @param {number} taskKey 
         * @param {UpdateTransactionProcessStatusEnum} processStatus 
         * @param {TransactionRequest} transactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransaction(taskKey: number, processStatus: UpdateTransactionProcessStatusEnum, transactionRequest: TransactionRequest, options?: RawAxiosRequestConfig): AxiosPromise<MainInfoWrapper> {
            return localVarFp.updateTransaction(taskKey, processStatus, transactionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserTaskControllerApi - object-oriented interface
 */
export class UserTaskControllerApi extends BaseAPI {
    /**
     * 
     * @summary Lấy danh sách giao dịch phân trang
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {GetAllTasksStateEnum} [state] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAllTasks(page?: number, pageSize?: number, state?: GetAllTasksStateEnum, options?: RawAxiosRequestConfig) {
        return UserTaskControllerApiFp(this.configuration).getAllTasks(page, pageSize, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lấy chi tiết giao dịch taskKey
     * @param {number} taskKey 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDetailTransactionByTaskKey(taskKey: number, options?: RawAxiosRequestConfig) {
        return UserTaskControllerApiFp(this.configuration).getDetailTransactionByTaskKey(taskKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Hành động giao dịch
     * @param {number} taskKey 
     * @param {UpdateTransactionProcessStatusEnum} processStatus 
     * @param {TransactionRequest} transactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateTransaction(taskKey: number, processStatus: UpdateTransactionProcessStatusEnum, transactionRequest: TransactionRequest, options?: RawAxiosRequestConfig) {
        return UserTaskControllerApiFp(this.configuration).updateTransaction(taskKey, processStatus, transactionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetAllTasksStateEnum = {
    Creating: 'CREATING',
    Created: 'CREATED',
    Assigning: 'ASSIGNING',
    Updating: 'UPDATING',
    Completing: 'COMPLETING',
    Completed: 'COMPLETED',
    Canceling: 'CANCELING',
    Canceled: 'CANCELED',
    Failed: 'FAILED',
    UnknownEnumValue: 'UNKNOWN_ENUM_VALUE'
} as const;
export type GetAllTasksStateEnum = typeof GetAllTasksStateEnum[keyof typeof GetAllTasksStateEnum];
export const UpdateTransactionProcessStatusEnum = {
    EmpCreated: 'EMP_CREATED',
    EmpDraft: 'EMP_DRAFT',
    EmpSubmited: 'EMP_SUBMITED',
    AccRecepted: 'ACC_RECEPTED',
    AccReturn: 'ACC_RETURN',
    AccRejected: 'ACC_REJECTED',
    AccApproved: 'ACC_APPROVED',
    RdRecepted: 'RD_RECEPTED',
    RdReturn: 'RD_RETURN',
    RdAccepted: 'RD_ACCEPTED',
    Canceled: 'CANCELED'
} as const;
export type UpdateTransactionProcessStatusEnum = typeof UpdateTransactionProcessStatusEnum[keyof typeof UpdateTransactionProcessStatusEnum];


/**
 * UsersControllerApi - axios parameter creator
 */
export const UsersControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        me: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = '*/*';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersControllerApi - functional programming interface
 */
export const UsersControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async me(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.me(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersControllerApi.me']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersControllerApi - factory interface
 */
export const UsersControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        me(options?: RawAxiosRequestConfig): AxiosPromise<UserInfoResponse> {
            return localVarFp.me(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersControllerApi - object-oriented interface
 */
export class UsersControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public me(options?: RawAxiosRequestConfig) {
        return UsersControllerApiFp(this.configuration).me(options).then((request) => request(this.axios, this.basePath));
    }
}



